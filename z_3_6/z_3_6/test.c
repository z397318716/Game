#include<stdio.h>
#include<stdlib.h>


int main(){
	//创建一个静态的数组  数组的大小在编译时已经决定了
	int arr[100] = { 0 };

	// (在堆上)创建一个动态的数组, 运行时决定数组的大小 
	// 内存泄漏 : 堆上申请的内存生命周期比较长,如果用完之后不手动释放的话
	//           后续再申请堆上的内存可能就会申请失败(内存不够),把不需要使用的内存
	//           及时的释放掉
	//    如果没有及时的释放掉,此时产生的现象,就叫内存泄漏
	//    如果 malloc 申请的内存,本来还需要使用,但是被提前释放了,此时再去使用这个内存,就会出现未定义行为


	// c++ 之后的大部分编程语言都引入了垃圾回收机制(GC),能够有效的简化程序员对内存的操心程度
	// 但是 GC 机制最大的问题是引入了很大的额外开销,以及最致命的 STW(stop the world) 问题  (Java 在这个方面其实已经优化的非常好了)
	
	// C++ 的核心价值观
	// 1.高效(性能榨汁机 能够将机器的性能发挥到极致)
	// 2.和C兼容

	// 智能指针 (解决 内存泄漏 的比较有效的方法)


	int n= 100;
	//假设第一次 malloc 返回的结果 0x100
	//假设第二次 malloc 返回的结果 0x200
	//第二次的 malloc 会覆盖掉第一次的 0x100,导致接下来的 free释放失败 进而造成内存泄漏
	int* ptr = (int*)malloc(sizeof(int)* n);
	ptr = (int*)malloc(sizeof(int)* n);
	for (int i = 0; i < 100; ++i){
		ptr[i] = i;//相当于  *(ptr + i)=i; // ptr加上i 然后解引用
	}
	free(ptr);

	// 对一个已经释放的内存,在释放一次,这也是未定义行为  ()
	int* ptr1 = (int*)malloc(sizeof(int)* n);
	free(ptr1);
	free(ptr1);

	// 合理的做法是: 如果释放了内存,就把指针置为空
	// 对 NULL(空指针)进行 free ,没事
	ptr1 = NULL;
	free(ptr1);

	system("pause");
	return 0;
}